# Занятие I

## Возведение в степень

*x*<sup>1000</sup> = *x* &times; ... &times; *x*

999 умножений. Частой ошибкой у начинающих программистов является &laquo;ошибка на единицу&raquo;.
Многие, не подумав, утверждают, что возведение в степень 1000 означает 1000 умножений, но на самом деле
умножений будет меньше. Возведение в квардрат *x*<sup>2</sup> означает *x* &times; *x*, здесь мы видим одно
умножение. Возведение в куб *x* &times; *x* &times; *x*&nbsp;&mdash; два умножения. Количество умножений
на единицу меньше степени.

Быстрый алгоритм возведения в степень опирается на разложение в двоичный ряд.

1000<sub>10</sub> = 1111101000<sub>2</sub>

Мы видим, что в двоичном представлении установлены 3, 5, 6, 7, 8 и 9 биты. Нумерация битов начинается с 0 справа налево.

Это значит, что 1000 = 2<sup>9</sup> + 2<sup>8</sup> + 2<sup>7</sup> + 2<sup>6</sup> + 2<sup>5</sup> + 2<sup>3</sup><br />
или<br />
1000 = 512 + 256 + 128 + 64 + 32 + 8

*x*<sup>1000</sup> = *x*<sup>2<sup>9</sup></sup> &times; *x*<sup>2<sup>8</sup></sup> &times; *x*<sup>2<sup>7</sup></sup> &times; *x*<sup>2<sup>6</sup></sup> &times; *x*<sup>2<sup>5</sup></sup> &times; *x*<sup>2<sup>3</sup></sup>

Если мы знаем x, мы можем быстро вычислить *x*<sup>2</sup> = *x* &times; *x*,
*x*<sup>4</sup> = *x*<sup>2</sup> &times; *x*<sup>2</sup>, *x*<sup>8</sup> = *x*<sup>4</sup> &times; *x*<sup>4</sup> и так далее.

Для вычисления *x*<sup>1000</sup> нам потребуются две переменные. Первая для самого младшего бита в разложении числа
будет равна основанию, то есть *x*. На каждой итерации мы будем проверять, чётное у нас осталось число или
нечётное. Для чётного числа мы будем возводить переменную в квадрат, тогда у нас будут получаться последовательно
значения *x*, *x*<sup>2</sup>, *x*<sup>4</sup>, *x*<sup>8</sup> и так далее.

Вторая будет хранить результат. Вначале она равна 1. Если мы не сделаем ни одного умножения, результат равен 1,
поскольку *x*<sup>0</sup> = 1. Если текущее значение в итерации нечётное, значит, нам встретился единичный бит в разложении.
Умножаем результат на значение первой переменной, то есть на *x* или *x*<sup>2</sup>, или *x*<sup>4</sup>...

```c#
BigInteger result = 1;

while (exponent > 0)
{
    if (exponent % 2 == 0)
    {
        @base *= @base;
        exponent /= 2;
    }
    else
    {
        result *= @base;
        exponent--;
    }
}
```

## Домашнее задание

Реализовать функцию и тесты для вычисления n-го числа Фибоначчи.

> fib(0) = 0<br />
> fib(1) = 1<br />
> fib(n) = fib(n - 1) + fib(n - 2)

Первые числа Фибоначчи: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, ...

Затем, опираясь на тесты, провести рефакторинг кода, реализовав быстрое вычисление чисел Фибоначчи из задачи 1.19
книги &laquo;Структура и Интерпретация Компьютерных Программ&raquo; (SICP, читается _сик-пи_).

Если *a* и *b*&nbsp;&mdash; два последовательных числа Фибоначчи, то мы можем вычислить следующее число так:

> *a'* = *a* + *b*<br />
> *b'* = *a*

Это частный случай формулы:

> *a'* = *b* * *q* + *a* * *q* + *a* * *p*<br />
> *b'* = *b* * *p* + *a* * *q*

при *p* = 0 и *q* = 1.

Возведением в квадрат для последовательности Фибоначчи будет двойное применение формулы.

Распишите вычисление *a''* и *b''* через *a* и *b*. Это можно выразить в виде:

> *a''* = *b* * *q'* + *a* * *q'* + *a* * *p'*<br />
> *b''* = *b* * *p'* + *a* * *q'*

Выразите *p'* и *q'* через *p* и *q*. Теперь вы можете реализовать быстрый алгоритмы Фибоначчи, который для каждого нулевого
бита будет вычислять новые значения *p* и *q* (сначала *p'* и *q'*, затем *p''* и *q''*), а для каждого единичного&nbsp;&mdash;
новые значения *a* и *b*.
