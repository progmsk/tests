# Модульные тесты (Unit Tests)

## Занятие I

### Возведение в степень

x<sup>1000</sup> = x &times; ... &times; x

999 умножений. Частой ошибкой у начинающих программистов является &laquo;ошибка на единицу&raquo;.
Многие, не подумав, утверждают, что возведение в степень 1000 означает 1000 умножений, но на самом деле
умножений будет меньше. Возведение в квардрат x<sup>2</sup> означает x &times; x, здесь мы видим одно
умножение. Возведение в куб x &times; x &times; x&nbsp;&mdash; два умножения. Количество умножений
на единицу меньше степени.

Быстрый алгоритм возведения в степень опирается на разложение в двоичный ряд.

1000<sub>10</sub> = 1111101000<sub>2</sub>

Мы видим, что в двоичном представлении установлены 3, 5, 6, 7, 8 и 9 биты. Нумерация битов начинается с 0 справа налево.

Это значит, что 1000 = 2<sup>9</sup> + 2<sup>8</sup> + 2<sup>7</sup> + 2<sup>6</sup> + 2<sup>5</sup> + 2<sup>3</sup><br />
или<br />
1000 = 512 + 256 + 128 + 64 + 32 + 8

x<sup>1000</sup> = x<sup>2<sup>9</sup></sup> &times; x<sup>2<sup>8</sup></sup> &times; x<sup>2<sup>7</sup></sup> &times; x<sup>2<sup>6</sup></sup> &times; x<sup>2<sup>5</sup></sup> &times; x<sup>2<sup>3</sup></sup>

Если мы знаем x, мы можем быстро вычислить x<sup>2</sup> = x &times; x,
x<sup>4</sup> = x<sup>2</sup> &times; x<sup>2</sup>, x<sup>8</sup> = x<sup>4</sup> &times; x<sup>4</sup> и так далее.

Для вычисления x<sup>1000</sup> нам потребуются две переменные. Первая для самого младшего бита в разложении числа
будет равна основанию, то есть x. На каждой итерации мы будем проверять, чётное у нас осталось число или
нечётное. Для чётного числа мы будем возводить переменную в квадрат, тогда у нас будут получаться последовательно
значения x, x<sup>2</sup>, x<sup>4</sup>, x<sup>8</sup> и так далее.

Вторая будет хранить результат. Вначале она равна 1. Если мы не сделаем ни одного умножения, результат равен 1,
поскольку x<sup>0</sup> = 1. Если текущее значение в итерации нечётное, значит, нам встретился единичный бит в разложении.
Умножаем результат на значение первой переменной, то есть на x или x<sup>2</sup>, или x<sup>4</sup>...

```c#
BigInteger result = 1;

while (exponent > 0)
{
    if (exponent % 2 == 0)
    {
        @base *= @base;
        exponent /= 2;
    }
    else
    {
        result *= @base;
        exponent--;
    }
}
```

### Домашнее задание

Реализовать функцию и тесты для вычисления n-го числа Фибоначчи.

fib(0) = 0<br />
fib(1) = 1<br />
fib(n) = fib(n - 1) + fib(n - 2)

Первые числа Фибоначчи: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, ...

Затем, опираясь на тесты, провести рефакторинг кода, реализовав быстрое вычисление чисел Фибоначчи из задачи 1.19
книги &laquo;Структура и Интерпретация Компьютерных Программ&raquo; (SICP, читается _сик-пи_).

Если a и b&nbsp;&mdash; два последовательных числа Фибоначчи, то мы можем вычислить следующее число так:

```
a' = a + b
b' = a
```

Это частный случай формулы:
```
a' = b * q + a * q + a * p
b' = b * p + a * q
```
при p = 0 и q = 1.

Возведением в квадрат для последовательности Фибоначчи будет двойное применение формулы.

Распишите вычисление a'' и b'' через a и b. Это можно выразить в виде:
```
a'' = b * q' + a * q' + a * p'
b'' = b * p' + a * q'
```

Выразите p' и q' через p и q. Теперь вы можете реализовать быстрый алгоритмы Фибоначчи, который для каждого чётного
бита будет вычислять новые значения p и q (сначала p' и q', затем p'' и q''), а для каждого нечётного&nbsp;&mdash;
новые значения a и b.
